VonBertalannfyGrowth <- function(FvD){
Model <- list()
Parameters <- data.frame(SexRatio=names(FvD), Linf = NA, K = NA, t0 = NA)
for (i in 1:length(FvD)) {
fert <- FvD[[i]][[2]][,2]
dens <- FvD[[i]][[2]][,1]
theta <- c(1, 0.001, 0.1)
out <- optim(theta, fn = SSQ, method = "BFGS", x = na.omit(dens),
dens = FvD[[i]][[2]][,1], fert=FvD[[i]][[2]][,2],  hessian = TRUE)
out$V <- solve(out$hessian)  #solve the hessian
out$S <- sqrt(diag(out$V))  #Standard Error
out$R <- out$V/(out$S %o% out$S)  #Correlation
Model[[i]] <- out
Parameters[i,2:4] <- out$par
}
return(list(Models=Model, Parameters=Parameters))
}
VBG.Models <- VonBertalannfyGrowth(FvD)
VBG.Models <- VonBertalannfyGrowth(FvD)
length(FvD)
fert <- FvD[[5]][[2]][,2]
dens <- FvD[[5]][[2]][,1]
SSQ <- function(theta, dens, fert) {
Linf <- theta[1]
K <- theta[2]
t0 <- theta[3]
epsilon <- rep(0, length(dens))
lpred <- rep(0, length(dens))
for (i in 1:length(dens)) {
lpred[i] <- Linf * (1 - exp(-K * (dens[i] - t0)))
epsilon[i] <- (fert[i] - lpred[i])^2
}
ssq <- sum(na.omit(epsilon))
return(ssq)
}
VonBertalannfyGrowth <- function(FvD){
Model <- list()
Parameters <- data.frame(SexRatio=names(FvD), Linf = NA, K = NA, t0 = NA)
for (i in 1:length(FvD)) {
fert <- FvD[[i]][[2]][,2]
dens <- FvD[[i]][[2]][,1]
theta <- c(1, 0.001, 0.1)
out <- optim(theta, fn = SSQ, method = "BFGS",
dens = na.omit(FvD[[i]][[2]][,1]), fert=FvD[[i]][[2]][,2],  hessian = TRUE)
out$V <- solve(out$hessian)  #solve the hessian
out$S <- sqrt(diag(out$V))  #Standard Error
out$R <- out$V/(out$S %o% out$S)  #Correlation
Model[[i]] <- out
Parameters[i,2:4] <- out$par
}
return(list(Models=Model, Parameters=Parameters))
}
VBG.Models <- VonBertalannfyGrowth(FvD)
fert <- FvD[[5]][[2]][,2]
out <- optim(theta, fn = SSQ, method = "BFGS", x = na.omit(dens), hessian = TRUE)
theta <- c(1, 0.1, 0.1)
out <- optim(theta, fn = SSQ, method = "BFGS", x = na.omit(dens), hessian = TRUE)
out <- optim(theta, fn = SSQ, method = "BFGS", dens = na.omit(dens), fert=fert, hessian = TRUE)
out$par
FvD[[1]][[1]]
head(FvD[[1]][[2]])
fert <- FvD[[1]][[2]][,2]
dens <- FvD[[1]][[2]][,1]
out <- optim(theta, fn = SSQ, method = "BFGS", dens = na.omit(dens), fert=fert, hessian = TRUE)
rm(c('dens', "fert"))
rm(dens, fert)
VonBertalannfyGrowth <- function(FvD){
Model <- list()
Parameters <- data.frame(SexRatio=names(FvD), Linf = NA, K = NA, t0 = NA)
for (i in 1:length(FvD)) {
fert <- FvD[[i]][[2]][,2]
dens <- FvD[[i]][[2]][,1]
theta <- c(1, 0.001, 0.1)
out <- optim(theta, fn = SSQ, method = "BFGS",
dens = na.omit(dens), fert=fert,  hessian = TRUE)
out$V <- solve(out$hessian)  #solve the hessian
out$S <- sqrt(diag(out$V))  #Standard Error
out$R <- out$V/(out$S %o% out$S)  #Correlation
Model[[i]] <- out
Parameters[i,2:4] <- out$par
}
return(list(Models=Model, Parameters=Parameters))
}
SSQ <- function(theta, dens, fert) {
Linf <- theta[1]
K <- theta[2]
t0 <- theta[3]
epsilon <- rep(0, length(dens))
lpred <- rep(0, length(dens))
for (i in 1:length(dens)) {
lpred[i] <- Linf * (1 - exp(-K * (dens[i] - t0)))
epsilon[i] <- (fert[i] - lpred[i])^2
}
ssq <- sum(na.omit(epsilon))
return(ssq)
}
VBG.Models <- VonBertalannfyGrowth(FvD)
VBG.Models <- VonBertalannfyGrowth(FvD)
fert <- FvD[[2]][[2]][,2]
dens <- FvD[[2]][[2]][,1]
theta <- c(1, 0.1, 0.1)
out <- optim(theta, fn = SSQ, method = "BFGS", dens = na.omit(dens), fert=fert, hessian = TRUE)
fert <- FvD[[9]][[2]][,2]
dens <- FvD[[9]][[2]][,1]
out <- optim(theta, fn = SSQ, method = "BFGS", dens = na.omit(dens), fert=fert, hessian = TRUE)
fert <- FvD[[8]][[2]][,2]
dens <- FvD[[8]][[2]][,1]
out <- optim(theta, fn = SSQ, method = "BFGS", dens = na.omit(dens), fert=fert, hessian = TRUE)
VBGPlot <- function(SR, FvD, Parameters) {
#Sex Ratio is integer from 1 to 9 relating to proportion of Males --> i.e 1 = 0.1M, 0.9F Sex Ratio
data <- FvD[[SR]][[2]]
fit <- Parameters[SR,2] * (1 - exp(-Parameters[SR, 3] * (data$dens - Parameters[SR,4])))
fit.data <- data.frame(dens=data$dens, fit=fit)
ggplot(data=data, aes(x=dens, y=fert)) +
geom_point() +
geom_smooth() +
geom_line(data=fit.data, aes(x=dens, y=fit), col="green", size=1) +
labs(x=expression(CoTS~Density~(km^{-2})),
y="% of Eggs Fertilised") +
ggtitle(paste(SR,"M:",10-SR, "F", sep="")) +
theme_classic()
}
Parameters <- data.frame(SexRatio=names(FvD), Linf = NA, K = NA, t0 = NA)
Parameters[8,2:4] <- out$par
VBGPlot(8, FvD, Parameters = VBG.Models[[8]])
VBGPlot(8, FvD, Parameters = Parameters)
out$par
fert <- FvD[[8]][[2]][,2]
dens <- FvD[[8]][[2]][,1]
out8 <- optim(theta, fn = SSQ, method = "BFGS", dens = na.omit(dens), fert=fert, hessian = TRUE)
out8$par
fert <- FvD[[9]][[2]][,2]
dens <- FvD[[9]][[2]][,1]
out9 <- optim(theta, fn = SSQ, method = "BFGS", dens = na.omit(dens), fert=fert, hessian = TRUE)
out9$par
fert <- FvD[[7]][[2]][,2]
dens <- FvD[[7]][[2]][,1]
out7 <- optim(theta, fn = SSQ, method = "BFGS", dens = na.omit(dens), fert=fert, hessian = TRUE)
VonBertalannfyGrowth <- function(FvD){
Model <- list()
Parameters <- data.frame(SexRatio=names(FvD), Linf = NA, K = NA, t0 = NA)
for (i in 1:length(FvD)) {
fert <- FvD[[i]][[2]][,2]
dens <- FvD[[i]][[2]][,1]
theta <- c(1, 0.001, 0.1)
out <- optim(theta, fn = SSQ, method = "BFGS",
dens = na.omit(dens), fert=fert,  hessian = TRUE)
#out$V <- solve(out$hessian)  #solve the hessian
#out$S <- sqrt(diag(out$V))  #Standard Error
#out$R <- out$V/(out$S %o% out$S)  #Correlation
Model[[i]] <- out
Parameters[i,2:4] <- out$par
}
return(list(Models=Model, Parameters=Parameters))
}
VBG.Models <- VonBertalannfyGrowth(FvD)
VBGPlot(8, FvD, Parameters = VBG.Models[[8]])
VBGPlot(8, FvD, Parameters = VBG.Models[["Parameters"]])
if(!require(devtools)) install.packages("devtools")
devtools::install_github("kassambara/ggpubr")
VBGPlot(2, FvD, Parameters = VBG.Models[["Parameters"]])
VBG.Models[["Parameters"]]
VBGPlot(3, FvD, Parameters = VBG.Models[["Parameters"]])
VBGPlots = list()
for (i in 1:9){
VBGPlots[[i]] = VBGPlot(i, FvD, Parameters = VBG.Models[["Parameters"]])
}
VBGPlots[[1]]
VBGPlots[[2]]
library(ggpubr)
ggarrange(VBGPlots)
ggarrange(unlist(VBGPlots))
ggarrange(VBGPlots[[1]], VBGPlots[[2]],VBGPlots[[3]], VBGPlots[[4]],
VBGPlots[[5]], VBGPlots[[6]], VBGPlots[[7]], VBGPlots[[8]],
VBGPlots[[9]])
warnings()
ggarrange(VBGPlots[[1]], VBGPlots[[2]],VBGPlots[[3]], VBGPlots[[4]],
VBGPlots[[5]], VBGPlots[[6]], VBGPlots[[7]], VBGPlots[[8]],
VBGPlots[[9]], ncol=3, nrow=3)
VBG.Models[[2]]
Params = VBG.Models[[2]]
nCOTS = 10000
fEGGS <- Params[SR,"Linf"] * (1 - exp(-Params[SR,"K"] * (nCOTS - Params[SR,"t0"])))
set.seed(1)
nEggs <- COTS_Fecundity(t1, 35, 10, npops=length(PopData[,1]))
SR = 5
fEggs <- Params[SR,"Linf"] * (1 - exp(-Params[SR,"K"] * (nCOTS - Params[SR,"t0"])))
COTS_Fertilisation = function(nEggs, nCOTS, SR, Params) {
# Von Bertanlanffy Growth = Proportion of Eggs fertilised
fEggs <- Params[SR,"Linf"] * (1 - exp(-Params[SR,"K"] * (nCOTS - Params[SR,"t0"])))
nLarvae = nEggs * fEggs
}
t1 <- COTS_StageTransition(COTSabund = initCOTS, COTSmort = COTSmort, COTSremain = COTSremain)
View(t1)
COTSabund <- COTS_StageTransition(COTSabund = initCOTS, COTSmort = COTSmort, COTSremain = COTSremain)
test = COTS_Fertilisation(nEggs = nEggs, nCOTS = COTSabund['A'], SR=5, Params = Params)
summary(test)
Params
COTSabund['A']
COTSabund <- COTS_StageTransition(COTSabund = initCOTS, COTSmort = COTSmort, COTSremain = COTSremain)
View(COTSabund)
test = COTS_Fertilisation(nEggs = nEggs, nCOTS = COTSabund[,'A'], SR=5, Params = Params)
summary(test)
summary(COTSabund[,"A"])
summary(nEggs)
nEggs <- COTS_Fecundity(COTSabund, 35, 10, npops=length(PopData[,1]))
Sizes <- rnorm(COTSabund[1,'A'], 35, 10)
summary(Sizes)
sum(COTS_FecFromMass(COTS_MassFromDiam(Sizes)))
COTS_FecFromMass(COTS_MassFromDiam(min(Sizes)))
nEggs <- COTS_Fecundity(COTSabund, 35, 10, npops=length(PopData[,1]))
summary(nEggs)
COTS_MassFromDiam(-3)
COTS_MassFromDiam(0)
COTS_FecFromMass(0)
COTS_Fecundity <- function(COTSabund, mean, sd, npops) {
### Intitialize matrix to store total eggs
COTS_Eggs <- vector(mode = "numeric", length = npops)
for (r in 1:npops) {
Sizes <- rnorm(COTSabund[r,'A'], mean, sd)
Sizes[Sizes<0] = 0
COTS_Eggs[r] <- sum(COTS_FecFromMass(COTS_MassFromDiam(Sizes)))
}
return(COTS_Eggs)
}
nEggs <- COTS_Fecundity(COTSabund, 35, 10, npops=length(PopData[,1]))
summary(nEggs)
test = COTS_Fertilisation(nEggs = nEggs, nCOTS = COTSabund[,'A'], SR=5, Params = Params)
summary(nEggs);summary(test)
COTS_Fecundity <- function(COTSabund, mean, sd, npops, SR) {
### Intitialize matrix to store total eggs
COTS_Eggs <- vector(mode = "numeric", length = npops)
for (r in 1:npops) {
Sizes <- rnorm(COTSabund[r,'A']*SR/10, mean, sd)
Sizes[Sizes<0] = 0
COTS_Eggs[r] <- sum(COTS_FecFromMass(COTS_MassFromDiam(Sizes)))
}
return(COTS_Eggs)
}
nEggs <- COTS_Fecundity(COTSabund, 35, 10, SR = 5, npops=length(PopData[,1]))
summary(nEggs)
nLarvae = COTS_Fertilisation(nEggs = nEggs, nCOTS = COTSabund[,'A'], SR=5, Params = Params)
summary(nEggs);summary(nLarvae)
npops = length(PopData[,1])
VBG.Params = VBG.Models[[2]]
SelfRecruit = rep(0.1, npops)
dim(Pdist.Sp)
Pdist.Sp.test = Pdist.Sp[1:1000, 1:1000]
sum(Pdist.Sp.test)[1,]
sum(Pdist.Sp.test[1,])
dim(Pdist.Sp.test)
Pdist.Sp[1:10,1:10]
Pdist.Sp[Pdist.Sp=Inf] = 1
Pdist.Sp.test = Pdist.Sp[1:1000, 1:1000]
sum(Pdist.Sp.test[1,])
Pdist.Sp[1:10,1:10]
Pdist.Sp[Pdist.Sp==Inf] = 1
Pdist.Sp.test = Pdist.Sp[1:1000, 1:1000]
sum(Pdist.Sp.test[1,])
Pdist.Sp[1:10,1:10]
sum(Pdist.Sp.test[1,][-1])
for (i in 1:length(npops)){
Pdist.sp[i,i] = 1
}
for (i in 1:length(npops)){
Pdist.Sp[i,i] = 1
}
Pdist.Sp.test = Pdist.Sp[1:1000, 1:1000]
sum(Pdist.Sp.test[1,])
sum(Pdist.Sp.test[5,])
Pdist.Sp[1:10,1:10]
Pdist.Sp[2,2]
Pdist.test = Pdist[1:1000, 1:1000]
Pdist.Sp[2,2] = 1
load("R_Objects/ProbDistance.Rdata")
setwd(BASE_DIRECTORY)
load("R_Objects/ProbDistance.Rdata")
sum(Pdist.Sp.test[2,])
sum(Pdist.Sp[2,])
Pdist = as.matrix(Pdist.Sp)
for (i in 1:length(npops)){
Pdist[i,i] = 1
}
Pdist[1:10,1:10]
Pdist[2,2] = 1
Pdist[1:10,1:10]
length(npops)
npops = length(PopData[,1])
Pdist[Pdist==Inf] = 1
Pdist[1:10,1:10]
rm(Pdist.Sp, Pdist.Sp.test)
Pdist.test = Pdist[1:1000, 1:1000]
nArriving = vector(mode="numeric", length = npops)
nLarvae = COTS_Fertilisation(nEggs = nEggs, nCOTS = COTSabund[,'A'], SR=5, Params = Params)
head(Pdist[1,]/sum(Pdist[1,]))
sum((Pdist[1,]/sum(Pdist[1,])))
nArriving = matrix(nrow = npops, ncol=npops)
nArriving[i,] = signif(nLarvae[i]*(Pdist.test[i,]/sum(Pdist.test[i,])),3)
for (i in 1:npops) {
nArriving[i,] = signif(nLarvae[i]*(Pdist.test[i,]/sum(Pdist.test[i,])),3)
}
View(nArriving)
nArriving = base::colSums(nArriving)
Loss=0.8
nLarvae = (1-Loss)*nLarvae # assume 80% lost to the sea
nArriving = matrix(nrow=npops, ncol=npops)
for (i in 1:npops) {
nArriving[i,] = signif(nLarvae[i]*(Pdist.test[i,]/sum(Pdist.test[i,])),3)
}
nArriving = base::colSums(nArriving)
COTSabund['J'] = COTSabund['J'] + nArriving
COTSabund <- COTS_StageTransition(COTSabund = initCOTS, COTSmort = COTSmort, COTSremain = COTSremain)
View(COTSabund)
COTSabund['J_1'] = COTSabund['J_1'] + nArriving
COTSabund['J_1']
COTSabund <- COTS_StageTransition(COTSabund = initCOTS, COTSmort = COTSmort, COTSremain = COTSremain)
COTSabund['J_1']
COTSabund[['J_1']] = COTSabund['J_1'] + nArriving
COTSabund[['J_1']]
COTSabund[,'J_1']
COTSabund[,'J_1'] = COTSabund[,'J_1'] + nArriving
CoTS_Dispersal <- function(ConnMat, COTSabund, nLarvae, SelfRecruit, CoralCover, Loss)
# PsuedoCode:
# 1. Loop through every population of fertilised eggs
# 2. Discard 80% of eggs, then distribute the remainder as a function of distance
# 3. Multiply nLarvae * connectivity probabilities to get larvae max
# 5. Determine path of larvae to estimate survival (leave this for now)
# 4. add vector of larvae produced to COTSabund
# 5. store as tbl (in dplyr you can store dataframes in dataframes)
nLarvae = (1-Loss)*nLarvae # assume 80% lost to the sea
nArriving = matrix(nrow=npops, ncol=npops)
for (i in 1:npops) {
nArriving[i,] = signif(nLarvae[i]*(ConnMat[i,]/sum(ConnMat[i,])),3)
}
nArriving = base::colSums(nArriving) # create total juveniles arriving
COTSabund[,'J_1'] = COTSabund[,'J_1'] + nArriving # add these to our abundance
return(COTSabund)
}
CoTS_Dispersal <- function(ConnMat, COTSabund, nLarvae, SelfRecruit, CoralCover, Loss){
# PsuedoCode:
# 1. Loop through every population of fertilised eggs
# 2. Discard 80% of eggs, then distribute the remainder as a function of distance
# 3. Multiply nLarvae * connectivity probabilities to get larvae max
# 5. Determine path of larvae to estimate survival (leave this for now)
# 4. add vector of larvae produced to COTSabund
# 5. store as tbl (in dplyr you can store dataframes in dataframes)
nLarvae = (1-Loss)*nLarvae # assume 80% lost to the sea
nArriving = matrix(nrow=npops, ncol=npops)
for (i in 1:npops) {
nArriving[i,] = signif(nLarvae[i]*(ConnMat[i,]/sum(ConnMat[i,])),3)
}
nArriving = base::colSums(nArriving) # create total juveniles arriving
COTSabund[,'J_1'] = COTSabund[,'J_1'] + nArriving # add these to our abundance
return(COTSabund)
}
COTSabund <- COTS_StageTransition(COTSabund = initCOTS, COTSmort = COTSmort, COTSremain = COTSremain)
nLarvae = COTS_Fertilisation(nEggs = nEggs, nCOTS = COTSabund[,'A'], SR=5, Params = Params)
COTSabund.t1 = CoTS_Dispersal(ConnMat = Pdist.test, COTSabund = COTSabund,
nLarvae=nLarvae, Loss=0.8)
View(COTSabund.t1)
doCoTS_Dispersal = function(season, COTSabund, SR){
if (season=="summer"){
nEggs = COTS_Fecundity(COTSabund,mean = 35, sd=10, SR = SR, npops = npops)
nLarvae = COTS_Fertilisation(nEggs = nEggs,SR = SR, Params = Params, nCOTS = COTSabund[,'A'])
COTSabund.t1 = CoTS_Dispersal(ConnMat = ConnMat, COTSabund = COTSabund,
nLarvae=nLarvae, Loss=0.8)
}
return(COTSabund.t1)
}
doCoTS_Dispersal = function(season, COTSabund, SR){
COTSabund.t1 = COTSabund
if (season=="summer"){
nEggs = COTS_Fecundity(COTSabund,mean = 35, sd=10, SR = SR, npops = npops)
nLarvae = COTS_Fertilisation(nEggs = nEggs,SR = SR, Params = Params, nCOTS = COTSabund[,'A'])
COTSabund.t1 = CoTS_Dispersal(ConnMat = ConnMat, COTSabund = COTSabund,
nLarvae=nLarvae, Loss=0.8)
}
return(COTSabund.t1)
}
initCOTS <- initializeCOTSabund(PopData = PopData, COTS.init = COTS.data, Year=1996, stagenames, COTS_StableStage = COTS_StableStage)
test.summer = doCoTS_Dispersal("summer", initCOTS, SR=5)
doCoTS_Dispersal = function(season, COTSabund, SR, ConnMat){
COTSabund.t1 = COTSabund
if (season=="summer"){
nEggs = COTS_Fecundity(COTSabund,mean = 35, sd=10, SR = SR, npops = npops)
nLarvae = COTS_Fertilisation(nEggs = nEggs,SR = SR, Params = Params, nCOTS = COTSabund[,'A'])
COTSabund.t1 = CoTS_Dispersal(ConnMat = ConnMat, COTSabund = COTSabund,
nLarvae=nLarvae, Loss=0.8)
}
return(COTSabund.t1)
}
test.summer = doCoTS_Dispersal("summer", initCOTS, SR=5, ConnMat = Pdist.test)
test.winter = doCoTS_Dispersal("winter", initCOTS, SR=5, ConnMat = Pdist.test)
View(test.summer)
View(test.winter)
test.summer = doCOTSDemography("summer", initCOTS)
doCOTSDemography = function(season, COTSabund){
COTSabund.t1 = COTSabund
if (season=="winter"){
COTSabund.t1 = COTS_StageTransition(COTSabund, COTSmort, COTSremain)
}
return(COTSabund.t1)
}
test.summer = doCOTSDemography("summer", initCOTS)
test.winter = doCOTSDemography("winter", initCOTS)
Results = data.frame(Year=NA, Season=NA, COTSabund=NA,CoralCover=NA)
Results[,1:5] = rep(PopData, NYEARS*NSEASONS)
NYEARS*NSEASONS
Results[,1:5] = sapply(PopData, rep.int, times=NYEARS*NSEASONS)
View(Results)
Results = data.frame(PIXEL_ID=NA, lon=NA, lat=NA, reefpercent=NA, REEF_ID=NA,
Year=NA, Season=NA, COTSabund=NA,CoralCover=NA)
View(Results)
Results[,1:5] = sapply(PopData, rep.int, times=NYEARS*NSEASONS)
sapply(PopData, rep.int, times=NYEARS*NSEASONS)
Results = data.frame(sapply(PopData, rep.int, times=NYEARS*NSEASONS),
Year=NA, Season=NA, COTSabund=NA,CoralCover=NA)
View(Results)
rep(1:3,3)
rep(1:3,times=3)
rep(1:3,each=3)
Results = data.frame(sapply(PopData, rep.int, times=NYEARS*NSEASONS),
Year=rep(1996:2005,each=2*npops), Season=rep(c("summer", "winter"),each=npops), COTSabund=NA,CoralCover=NA)
View(Results)
Results = data.frame(sapply(PopData, rep.int, times=NYEARS*NSEASONS),
Year=rep(1996:2005,each=2*npops), Season=rep(c("summer", "winter"),each=npops),
COTSJ1=NA, COTSJ2=NA, COTSA=NA, CoralCover=NA)
year = 1997
season = "winter"
test = Results[Year==year & Season=season]
test = Results[Year==year & Season==season]
test = Results[Results$Year==year & Results$Season==season]
test = Results[Results$Year==year & Results$Season==season]
test = Results[(Results$Year==year) & (Results$Season==season)]
Results[(Results$Year==year) & (Results$Season==season),"COTSJ1" ] = "test"
Results[(Results$Year==year) & (Results$Season==season),"COTSJ1" ] = NA
season = "summer"
Results[(Results$Year==year) & (Results$Season==season),8:10] = COTSabund.t1
View(Results)
View(COTSabund.t1)
Results[(Results$Year==year) & (Results$Season==season),8:10] = COTSabund.t1
View(Results)
Results[(Results$Year==year) & (Results$Season==season),8:10] = COTSabund.t1[,1:3]
Results[(Results$Year==year) & (Results$Season==season),8:10] = "test"
View(Results)
year = 1996
season = "summer"
Results[(Results$Year==year) & (Results$Season==season),"COTSJ1"] = "test"
Results[(Results$Year==year) & (Results$Season==season),c("COTSJ1", "COTSJ2", "COTSA")] = COTSabund.t1
Results$COTSJ1=as.numeric(Results$COTSJ1)
Results$COTSJ2=as.numeric(Results$COTSJ2)
Results$COTSA=as.numeric(Results$COTSA)
View(Results)
COTSabund = initializeCOTSabund(PopData = PopData, COTS.init = COTS.data,
Year=1996, stagenames, COTS_StableStage = COTS_StableStage)   # initialize the COTS abundance object (for year 0)
Results = data.frame(sapply(PopData, rep.int, times=NYEARS*NSEASONS),
Year=rep(1996:2005,each=2*npops), Season=rep(c("summer", "winter"),each=npops),
COTSJ1=NA, COTSJ2=NA, COTSA=NA, CoralCover=NA, DistCOTS=NA, DistCYCL=NA, DistBLCH=NA)
for(year in 1996:2005){                  # loop through years
for(season in SEASONS){               # loop through seasons
COTSabund = doCOTSDispersal(season,COTSabund,SR,ConnMat)
COTSabund = doCOTSDemography(season,COTSabund = COTSabund.t1)
# CoralCover.t1 = doCoralDispersal(season, CoralCover...)
# CoralCover.t1 = doCoralDisturbance(season,CoralCover,...)           # coral disturbance processes, including from COTS
Results[(Results$Year==year) & (Results$Season==season),
c("COTSJ1", "COTSJ2", "COTSA")] = COTSabund
}
}
doCOTSDispersal = function(season, COTSabund, SR, ConnMat){
COTSabund.t1 = COTSabund
if (season=="summer"){
nEggs = COTS_Fecundity(COTSabund,mean = 35, sd=10, SR = SR, npops = npops)
nLarvae = COTS_Fertilisation(nEggs = nEggs,SR = SR, Params = Params, nCOTS = COTSabund[,'A'])
COTSabund.t1 = CoTS_Dispersal(ConnMat = ConnMat, COTSabund = COTSabund,
nLarvae=nLarvae, Loss=0.8)
}
return(COTSabund.t1)
}
for(year in 1996:2005){                  # loop through years
for(season in SEASONS){               # loop through seasons
COTSabund = doCOTSDispersal(season,COTSabund,SR,ConnMat)
COTSabund = doCOTSDemography(season,COTSabund = COTSabund.t1)
# CoralCover.t1 = doCoralDispersal(season, CoralCover...)
# CoralCover.t1 = doCoralDisturbance(season,CoralCover,...)           # coral disturbance processes, including from COTS
Results[(Results$Year==year) & (Results$Season==season),
c("COTSJ1", "COTSJ2", "COTSA")] = COTSabund
}
}
ConnMat=Pdist.test
for(year in 1996:2005){                  # loop through years
for(season in SEASONS){               # loop through seasons
COTSabund = doCOTSDispersal(season,COTSabund,SR,ConnMat)
COTSabund = doCOTSDemography(season,COTSabund = COTSabund.t1)
# CoralCover.t1 = doCoralDispersal(season, CoralCover...)
# CoralCover.t1 = doCoralDisturbance(season,CoralCover,...)           # coral disturbance processes, including from COTS
Results[(Results$Year==year) & (Results$Season==season),
c("COTSJ1", "COTSJ2", "COTSA")] = COTSabund
}
}
Results = data.frame(sapply(PopData, rep.int, times=NYEARS*NSEASONS),
Year=rep(1996:2005,each=2*npops), Season=rep(c("summer", "winter"),each=npops),
COTSJ1=NA, COTSJ2=NA, COTSA=NA, CoralCover=NA, DistCOTS=NA, DistCYCL=NA, DistBLCH=NA)
for(year in 1996:1998){                  # loop through years
for(season in SEASONS){               # loop through seasons
COTSabund = doCOTSDispersal(season,COTSabund,SR,ConnMat)
COTSabund = doCOTSDemography(season,COTSabund = COTSabund.t1)
# CoralCover.t1 = doCoralDispersal(season, CoralCover...)
# CoralCover.t1 = doCoralDisturbance(season,CoralCover,...)           # coral disturbance processes, including from COTS
Results[(Results$Year==year) & (Results$Season==season),
c("COTSJ1", "COTSJ2", "COTSA")] = COTSabund
}
}
