---
title: "COTS_Model"
author: "Samuel Matthews"
date: "21 November 2018"
output:
  html_document:
    toc: true
    code_folding: hide
    toc_float: true
    theme: cosmo
    highlight: haddock
---


# Major Challenges
   
    1. I think we need to move everything to a reef level instead of a pixel based scenario.. Having multiple COTS populations on a ref make its hard to intigate a reef wide collapse.
    2. following a collapse COTS numbers stay at 0 until returning to directly to carrying capacity
    3. need to build a matlines plot to show each different replicate


# Preparing the Workspace

This section of the model sets up the directories to access data and to save files

```{r cars, cache=T, eval=T}
# CLEAR THE WORKSPACE ----
#######################!

rm(list=ls())

####
# SET USER ----
####

USER = "SAM_UNI"
# USER = "SAM_RENO"


#################!
# SET GLOBAL VARIABLES  (USER SPECIFIED PARAMS) ----
####

# NREPS <- 10      
NYEARS <- 20
NSEASONS <- 2
seasons <- c("summer","winter")
npops = 6000 #number of reefs we want to test

VERBOSE <- TRUE        # flag whether functions should return detailed information
DEBUG <- TRUE          # flag whether to output debug files etc. 

projection <- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"   #"+proj=lcc +lat_1=33 +lat_2=45 +lat_0=39 +lon_0=-96 +x_0=0 +y_0=0 +ellps=GRS80 +units=m +no_defs"

stagenames <- c('J_1', 'J_2', 'A')
COTSmort <- c(0.8,0.7,0.2)
names(COTSmort) <- stagenames
COTSremain <- c(0.02,0.2,1) # proportion remianing in each life stage --> we can make this a function of resource
names(COTSremain) <- stagenames
#VBG.Params = VBG.Models[[2]]

COTS_StableStage <- c(0.9803, 0.0171, 0.0026)   # very approximate stable stage distribution (J1, J2, Adult: see below for back-of-the-envelope calculation)
```

## Set Project Directories

```{r Project Directories,eval=T, cache=TRUE}

####
# SET PROJECT DIRECTORIES ----
####

# (this should be the only place where local directories should be referenced)

if(USER=="KEVIN") BASE_DIRECTORY <- "C:\\Users\\Kevin\\Dropbox\\CoTS_Model"             # NOTE: this should link to the Dropbox folder with shared project resources	                                                                        
if(USER=="KEVIN") CODE_DIRECTORY <- "C:\\Users\\Kevin\\GIT\\COTS_Model"              # NOTE: code directory should be your local copy of the GitHub repository

if(USER=="SAM") BASE_DIRECTORY <- "C:\\Users\\jc312264\\Dropbox\\CoTS_Model"
if(USER=="SAM") CODE_DIRECTORY <- "C:\\Users\\jc312264\\Documents\\GitHub\\COTS_Model"

if(USER=="SAM_UNI") BASE_DIRECTORY <- "C:\\Users\\jc312264\\Dropbox\\CoTS_Model"
if(USER=="SAM_UNI") CODE_DIRECTORY <- "C:\\Users\\jc312264\\OneDrive - James Cook University\\GitHub\\COTS_Model"

if(USER=="SAM_RENO") BASE_DIRECTORY <- "C:\\Users\\kshoemaker\\Dropbox\\CoTS_Model"
if(USER=="SAM_RENO") CODE_DIRECTORY <- "C:\\Users\\kshoemaker\\Documents\\GitHub\\COTS_Model"

SPATIALDATA_DIRECTORY <- paste(BASE_DIRECTORY,"\\Spatial Layers",sep="")                          # directory for storing relevant spatial data (ASC, SHP files)
if(is.na(file.info(SPATIALDATA_DIRECTORY)[1,"isdir"])) dir.create(SPATIALDATA_DIRECTORY)

DATA_DIRECTORY <- paste(BASE_DIRECTORY,"\\Data",sep="")                                 # directory for storing data (CSV files)
if(is.na(file.info(DATA_DIRECTORY)[1,"isdir"])) dir.create(DATA_DIRECTORY)

ENVDATA_DIRECTORY <- paste(DATA_DIRECTORY,"\\Environmental",sep="")                                 # directory for storing data (CSV files)
if(is.na(file.info(ENVDATA_DIRECTORY)[1,"isdir"])) dir.create(ENVDATA_DIRECTORY)

FIGURES_DIRECTORY <- paste(BASE_DIRECTORY,"\\Figures\\RawFigures",sep="")               # directory for storing raw figures generated from R
if(is.na(file.info(FIGURES_DIRECTORY)[1,"isdir"])) dir.create(FIGURES_DIRECTORY)

RESULTS_DIRECTORY <- paste(BASE_DIRECTORY,"\\results",sep="")                           # directory for storing relevant results
if(is.na(file.info(RESULTS_DIRECTORY)[1,"isdir"])) dir.create(RESULTS_DIRECTORY)

RDATA_DIRECTORY <- paste(BASE_DIRECTORY,"\\R_Workspaces",sep="")                        # directory for storing .RData files (R workspaces and data objects)
if(is.na(file.info(RDATA_DIRECTORY)[1,"isdir"])) dir.create(RDATA_DIRECTORY)

cat(sprintf("The current user is %s",USER))

```

## Load Functions, Packages and Data

```{r Load, eval=T, cache=T}
##################!
# LOAD FUNCTIONS AND SCRIPTS FROM SOURCE CODE (your local GitHub repository) ----
##################!

setwd(CODE_DIRECTORY)
source("COTSModel_Utilityfunctions.R")   # load utility functions, e.g., for loading packages etc.
source("COTSModel_COTSfunctions.R")      # load functions for implementing COTS demography and dispersal
source("COTSModel_Coralfunctions.R")     # load functions for implemeting coral growth/recovery and dispersal
source("COTSModel_GISfunctions.R")     # load functions for implemeting coral growth/recovery and dispersal

#####################!
# LOAD PACKAGES ----
#####################!
# note: 'loadPackage' should install the package from CRAN automatically if it is not already installed

loadPackages()   # load all packages into the global environment 
# THis only installs packages now.. everything else will be defined inline

`%>%` <- magrittr::`%>%` # bringt the pipe operator into the global environment

#####################!
# LOAD DATA FOR MODELLING ----
#####################!
setwd(CODE_DIRECTORY)
source("COTSModel_LoadObjectsForModelling.R")
CC_Per_CC = (data.grid$PercentReef/10000)*1e6*1e4 
COTS_Per_CC = CC_Per_CC/(250*365)
Crash=5

# save global params
saveWorkspace(filename="GlobalParams.RData", dir=RDATA_DIRECTORY)
```



# Model Structure and Functions

FIgure 1 below describes the general framework for the COTS model. A dataframe is set up to create latin hypercube samples, then the model is run for each sample and stored as a `.Rdata` file. Each function is described in detail below. 

![Model Structure](C:/Users//jc312264//Dropbox//CoTS_Model//MindMaps//Structure.png)

## makeLHSsamples

+ __Objective__: This function creates _n_ replicates across paremeter space for an individual model run
+ __Paremeters__: 
    + __NREPS__: number of replicate samples we wish to draw from parameter space
+ __Returns__: 
    + __masterDF__: n x 14 dataframe containing the parameters for that 
    + __.csv__: masterDF is written to the Results Directory

+ _Major Issues_: No major issues at this time, the biggest concern is developing more realisic densit dependent parameters to sample across

```{r makeLHSSample, eval=T}

MakeLHSSamples <- function(NREPS){
  
  # Information necessary to translate standard uniform LHS sample into parameters of interest
  specifyLHSParam <- function(paramslist,name,type,lb,ub){
    newlist <- paramslist
    eval(parse(text=sprintf("newlist$%s <- list()",name)))
    eval(parse(text=sprintf("newlist$%s$type <- \"%s\"",name,type)))
    eval(parse(text=sprintf("newlist$%s$lb <- %s",name,lb)))
    eval(parse(text=sprintf("newlist$%s$ub <- %s",name,ub))) 	
    return(newlist)
  }
  
  LHSParms <- list()    # initialize the container for parameter bounds
  
  ### SEXRATIO : 1 = 0.1M:0.9F
  LHSParms <- specifyLHSParam(paramslist=LHSParms,name="SexRatio",type="CAT",lb=0,ub=9)
  
  ####  WINTER CONSUMPTION RATE
  LHSParms <- specifyLHSParam(LHSParms,"ConsRateW",type="CONT",lb=100,ub=200)
  
  #### SUMMER CONSUMPTION RATE
  LHSParms <- specifyLHSParam(LHSParms,"ConsRateS",type="CONT",lb=150,ub=400)
  
  ### AVERAGE PER CAPITA FECUNDITY 
  LHSParms <- specifyLHSParam(LHSParms,"avgPCF",type="CONT",lb=42e5,ub=21e6)       
  
  ### STD DEV PER CAPITA FECUNDITY
  LHSParms <- specifyLHSParam(LHSParms,"sdPCF",type="CONT",lb=6e4,ub=14.6e4)      
  
  ### % JUVENILE1 MORTALITY PER TIME STEP
  LHSParms <- specifyLHSParam(LHSParms,"mortJ1",type="CONT",lb=0.9,ub=0.99)
  
  ### % JUVENILE2 MORTALITY PER TIME STEP
  LHSParms <- specifyLHSParam(LHSParms,"mortJ2",type="CONT",lb=0.6,ub=0.99) 
  
  ### % ADULT MORTALITY PER TIME STEP
  LHSParms <- specifyLHSParam(LHSParms,"mortA",type="CONT",lb=0.1,ub=0.6)
  
  ### % JUVENILE1 TO REMIAIN during transition
  LHSParms <- specifyLHSParam(LHSParms,"remJ1",type="CONT",lb=0.01,ub=0.5)
  
  ### % JUVENILE2 TO REMIAIN during transition 
  LHSParms <- specifyLHSParam(LHSParms,"remJ2",type="CONT",lb=0.1,ub=0.5)      
  
  ### % ADULT TO REMIAIN during transition
  LHSParms <- specifyLHSParam(LHSParms,"remA",type="CONT",lb=1,ub=1)      
  
  ### PROPORTIONAL STABLE STAGE DISTRIBUTION J1
  LHSParms <- specifyLHSParam(LHSParms,"cssJ1",type="CONT",lb=0.9803,ub=0.9803)
  
  ### PROPORTIONAL STABLE STAGE DISTRIBUTION J2
  LHSParms <- specifyLHSParam(LHSParms,"cssJ2",type="CONT",lb=0.0171,ub=0.0171) 
  
  ### PROPORTIONAL STABLE STAGE DISTRIBUTION a
  LHSParms <- specifyLHSParam(LHSParms,"cssA",type="CONT",lb=0.0026,ub=0.0026)
  
  
  ##### GENERATE LATIN HYPERCUBE SAMPLE
  
  nVars <- length(names(LHSParms))  
  
  LHS <- lhs::randomLHS(NREPS, nVars )   # generate multiple samples from parameter space according to a LHS sampling scheme
  
  masterDF <- as.data.frame(LHS)    #  storage container (data frame) to record relevant details for each file. Rows LHS samples. Cols: relevant variables
  
  
  ### translate raw lhs samples into desired parameter space
  colnames(masterDF) <- names(LHSParms)
  parm=1
  for(parm in 1:nVars){
    if(LHSParms[[parm]]$type=="CONT"){
      masterDF[,parm] <- LHSParms[[parm]]$lb + LHS[,parm]*(LHSParms[[parm]]$ub-LHSParms[[parm]]$lb)
    }
    if(LHSParms[[parm]]$type=="CAT"){
      masterDF[,parm] <- ceiling(LHSParms[[parm]]$lb + LHS[,parm]*(LHSParms[[parm]]$ub-LHSParms[[parm]]$lb))
    }
  }
  
  setwd(RESULTS_DIRECTORY)
  ## name file for LHS parameters 
  write.csv(masterDF,"masterDF_prelimCOTS.csv",row.names=F)
  
  return(masterDF)
}

####################!
# GENERATE LATIN HYPERCUBESAMPLE ----
####################!

masterDF = MakeLHSSamples(NREPS = 10)

```

## initalizeCOTSabund

+ __Objective__: Create a npops x 3 matrix to store COTS abundances (COTSabund) as the model progress
+ __Paremeters__:
    + __data.grid__: XYZ grid conatining all metadata for each pixel and environmental variables
    + __data.COTS__: interpolated COTS per manta tow dataframe used to initialize the COTS populations
    + __Year__: which year we choose to start from (usually 1996)
    + __stagenames__: character vector containing the names of the COTS stages (e.g J_1, J_2, A)
    + __COTS_StableStage__: 3 element vector conatinin the estimated proportions of J_1 and J_2 COTS to support the initialized adult population
+ __Returns__:
    + __COTSabund__: npops x 3 matrix containing our starting values of COTS

+ _Major Issues_: I need to make a more reliable estimate of the stable stage distribution, I can probably get this from Cameron Fletcher


```{r initializeCOTSabund}
initializeCOTSabund <- function(data.grid, data.COTS, Year, stagenames, COTS_StableStage){
  # browser()
  ### set NA Values in interpolation CoTS.init to 0
  data.COTS[is.na(data.COTS)] <- 0
  
  nstages <- length(stagenames)
  
  ### Set up the COTS abundance object
  COTSabund <- matrix(0,nrow=npops, ncol=nstages)
  colnames(COTSabund) <- stagenames
  
  ### Set up reference for year
  colname <- paste('COTS_', Year, sep="")
  
  ### Update abundances based from interpolated manta tow data
  COTSabund[,'A'] <- round(data.COTS[,colname] * 666 * (data.grid$PercentReef/100),0)   # 666 converts manta tow to 1kmx1km
  COTSabund[,'J_2'] <- round(COTSabund[,'A'] * as.numeric(COTS_StableStage[2]/COTS_StableStage[3]),0)
  COTSabund[,'J_1'] <- round(COTSabund[,'A'] * as.numeric(COTS_StableStage[1]/COTS_StableStage[3]),0)
  return(COTSabund)
}
```


## doCOTSDispersal

+ __Objective__: This function computes the larvae produced for each population and then distributes them to the other reefs withn the system via Karlo's mean Connectivity network.
+ __Paremeters__: 
    + __season__: `"summer"` or `"winter"`
    + __COTSabund__: npops x 3 matrix containing COTS abundances for the 3 stages
    + __SexRatio__: 1-10 indicating the ratio of F:M in the population
    + __ConnMat__: Connectivity Matrix filtered by only the reefs selected in npops
    + __PCFParams__: 2 element vector containg the average and sd of percapita fecundity 
    + __Pred__: Proportion of larve lost to predation (NEEDS to be included as at unable parameter)
    + __FvDparams__: Fertilisation by Density parameters
+ __Returns__: 
    + __COTSabund__

+ _Major Issues_: 
    + We need a standard deviation for the connectivity network as well as the mean.
    + I would like to make Per-Capita fecundity density dependent, or related to food availability
    + Needs an element of maternual condition
    + We need another stageclass to represent larger more fertile individuals 

```{r}
doCOTSDispersal = function(season, COTSabund, SexRatio, ConnMat, PCFParams, Pred, FvDParams){
  #browser()
  COTSabund = COTSabund
  if (season=="summer"){
    nEggs = COTSabund[,'A']*rnorm(1, PCFParams[1], PCFParams[2])*((10-SexRatio)/10)
    fEggs = FvDParams[SexRatio,"Linf"] * (1 - exp(-FvDParams[SexRatio,"K"] * (COTSabund[,'A'] - FvDParams[SexRatio,"t0"])))
    nLarvae = nEggs * fEggs
    # Do Dispersal ----
    nLarvae = ifelse(nLarvae < 0 , 0, nLarvae) 
    nLarvae = as.matrix((1-Pred)*nLarvae) # assume 80% lost to the sea
    row.names(nLarvae) = data.grid$REEF_NAME
    nLarvae_Reef = rowsum(nLarvae, row.names(nLarvae), reorder = F) 
    nArriving_Reef = ConnMat
    nArriving_Reef[nArriving_Reef > 0] = 0
    for (i in 1:length(nLarvae_Reef)) {
      nArriving_Reef[i,] = signif(nLarvae_Reef[i]*(ConnMat[i,]),3)
    }
    nArriving_Reef = base::colSums(nArriving_Reef, na.rm = T) # create total juveniles arriving at a reef
    nArriving_Reef_PerPix = nArriving_Reef/Pixels$Pixels
    names(nArriving_Reef_PerPix) = colnames(ConnMat)
    nArriving = nArriving_Reef_PerPix[match(data.grid$REEF_NAME, colnames(ConnMat))]
    COTSabund[,'J_1'] = COTSabund[,'J_1'] + nArriving # add these to our abundance
  }
  return(COTSabund)
}
```

## doCOTSDemography

+ __Objective__: To transition COTS throughout their life stages
+ __Paremeters__:
    + __season__: `"summer"` or `"winter"`
    + __COTSabund__: npops x 3 matrix containing COTS abundances for the 3 stages
    + __COTSmort__: 3 element vector containg the fixed mortality rates per lifestage **PLACEHOLDER**
    + __COTSremain__: 3 element vector conatingin the proportion of individuals that will not progress to the next, but remain alive **PLACEHOLDER**
+ __Returns__:
    + __COTSabund__: 

+ _Major Issues_: Transitions NEED to become food limited --> `COTSmort` & `COTSremain`

```{r doCOTSdemography}
doCOTSDemography = function(season, COTSabund, COTSmort, COTSremain){
  

  newCOTSabund = COTSabund
  if (season=="winter"){ 
    #Set up matrices
    newCOTSabund <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))
    colnames(newCOTSabund) <- colnames(COTSabund)
    COTS_Mort <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))
    colnames(COTS_Mort) <- colnames(COTSabund)
    COTS_Remain <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))
    colnames(COTS_Remain) <- colnames(COTSabund)
    COTS_Trans <- matrix(0,nrow=nrow(COTSabund), ncol=ncol(COTSabund))
    colnames(COTS_Trans) <- colnames(COTSabund)
    
    # apply mortality
    COTS_Mort <- sweep(COTSabund,MARGIN=2,COTSmort,`*`)
    # update abundance
    newCOTSabund <- COTSabund - COTS_Mort
    
    # number of COTS remaining and transitioning for each stage based on post-mortality abundaces
    COTS_Remain <- sweep(newCOTSabund,MARGIN=2,COTSremain,`*`)
    COTS_Trans <- sweep(newCOTSabund,MARGIN=2,1-COTSremain,`*`)
    
    # update newCOTSabund
    newCOTSabund[, 'J_1'] <- round(COTS_Remain[,'J_1'],0)
    newCOTSabund[, 'J_2'] <- round(COTS_Remain[,'J_2'] + COTS_Trans[,'J_1'],0)
    newCOTSabund[, 'A'] <- round(COTS_Remain[,'A'] + COTS_Trans[,'J_2'],0)
  }
  return(newCOTSabund)
}
```

## doCoralDisturbance

+ __Objective__: 
+ __Paremeters__:
+ __Returns__:

+ _Major Issues_: Not implemented yet

## doPredPreyDynamics

+ __Objective__: To limit COTS growth to Carrying Capacity. Includes a population crash mechanism `Crash` (0-7%Coral Cover) the level at which a COTS populaion will die off due to low amount of food.
+ __Paremeters__:
    + __season__: `"summer"` or `"winter"`
    + __COTSabund__: npops x 3 matrix containing COTS abundances for the 3 stages
    + __year__: current year in the model
    + __KC__: upper carrying capicity, estimated from highest obseved population levels (~200/mant tow) assuming 50% detectability for this methodolgy
    + __CoralCover__: Coral Cover for the current year
    + __Crash__: coral cover level at which the population will crash
+ __Returns__:
    + __COTSabund__: npops x 3 matrix containing COTS abundances for the 3 stages
+ _Major Issues_: This is the biggest issue with the model. 

```{r doPredPreyDynamics}
doPredPreyDynamics = function(season, year, COTSabund,KC, CoralCover, Crash) {
  # after 1 year at low levels COTS densities get brought down to levels supported by growth
  # work out the %CC growth from 0.5% and set that as the number of COTS
  # MinK is the Maximum CoTS that can be supported at depleted coral cover
  # Carry is overarching carrying capacity - cannot have more COTS than could eat the reef in 1 year
  # Carry = CoralCover*COTS_Per_CC
  COTSabund[,'A'] = ifelse(COTSabund[,'A']> KC, KC, COTSabund[,'A'])
  if(season=="summer"){
    # prevCC = dplyr::filter(Results, Year==year-1 & Season=='winter') %>% dplyr::select(CoralCover) %>% as.matrix()
    # browser()
    COTSabund[which(CoralCover < Crash),] = c(0,0,0)
    # COTSabund[which(prevCC < 10 & prevCC > 3 & COTSabund[,'A']> K$MinK.10A),] = 
    #   K$MinK.10A[which(prevCC < 10 & prevCC > 3 & COTSabund[,'A']> K$MinK.10A)]
  }
  if(season=="winter"){
    # prevCC = dplyr::filter(Results, Year==year & Season=='summer') %>% dplyr::select(CoralCover) %>% as.matrix()
    COTSabund[which(CoralCover < Crash),] = c(0,0,0)
    # COTSabund[which(prevCC < 10 & prevCC > 3 & COTSabund[,'A']> K$MinK.10A),] = 
    #   K$MinK.10A[which(prevCC < 10 & prevCC > 3 & COTSabund[,'A']> K$MinK.10A)]
  }
  
  return(COTSabund)
} 
```

## doCoralConsumption

+ __Objective__: Allow COTS to consume coral
+ __Paremeters__:    
    + __year__: current year in the model
    + __season__: `"summer"` or `"winter"`
    + __COTSabund__: npops x 3 matrix containing COTS abundances for the 3 stages
    + __CoralCover__: Coral Cover for the current year
    + __ConsRateS__: cm2 consumed per day in summer
    + __ConsRateW__: cm2 consumed per day in winter
+ __Returns__:        
    + __CRemaining__: Coral cover remaining
    + __CConsumed__: Coral cover consumed
+ __Major Issues__: Consumption rate should be size dependent, requiring another age stage

```{r doCoralConsumption}
doCoralConsumption = function(year, season, COTSabund, CoralCover, ConsRateS, ConsRateW) {
  if (season =="summer") {
    #CoralCover= Results[(Results$Year==year-1) & (Results$Season=="winter"),"CoralCover"]
    CAvailable = (CoralCover*data.grid$PercentReef/10000)*1e6*1e4 # in cm2
    CConsumed = ConsRateS*COTSabund[,"A"]*182
    CRemaining=((CAvailable-CConsumed)/1e10)*(10000/data.grid$PercentReef)
    CChange = CRemaining-CoralCover
    CRemaining[CRemaining < 0.5] <- 0.5
  } 
  if (season =="winter") {
    #CoralCover= Results[(Results$Year==year) & (Results$Season=="summer"),"CoralCover"]
    CAvailable = (CoralCover*data.grid$PercentReef/10000)*1e6*1e4 # in cm2
    CConsumed = ConsRateW*COTSabund[,"A"]*182
    CRemaining=((CAvailable-CConsumed)/1e10)*(10000/data.grid$PercentReef)
    CChange = CRemaining-CoralCover
    CRemaining[CRemaining < 0.5] <- 0.5
  }
  return(cbind(CRemaining, CChange))
}
```

## doCoralGrowth

+ __Objective__: Using Aaron's Coral growth estimates, apply the growth function to the current timestep
+ __Paremeters__:
    + __CoralCover__: Coral Cover for the current year (vector of length `npops`)
    + __B0__: intrinsic rate of growth for the pixel (vector of length `npops`)
    + __WQ__: WQ index for the pixel (vector of length `npops`)
    + __HC.asym__: Maximum hard coral cover for the pixel (vector of length `npops`)
+ __Returns__:
    + __CoralCover__: Updated coral cover
    + __CoralGrowth__: % Coral cover increase from growth

+ _Major Issues_: This function seems to work fine

```{r doCoralGrowth}
doCoralGrowth = function(CoralCover, B0, WQ, HC.asym) {
  b0.wq <- B0 + WQ * rnorm(length(WQ), mean=WQ.mn.sd[1], sd=WQ.mn.sd[2])
  b1.wq <- b0.wq / log(HC.asym)
  CoralCover <- log(CoralCover)
  CoralCover.t1 <- b0.wq + (1 - b1.wq)*CoralCover
  return(cbind(CoralCover=exp(CoralCover.t1), CoralGrowth=(exp(CoralCover.t1)-exp(CoralCover))))
}
```

## RunModel

+ __Objective__: To run the model for over the time series for `npops` (i.e pixels)
+ __Paremeters__:
    + __MasterDF__: dataframe holding the LHS selected parameters
    + __PopData__: dataframe holding metadata for each pixel
    + __COTS.data__: dataframe holding the interpolated COTS data, ussed to initialize abundances
    + __Years__: vector of years to run the model over. i.e `1996:2015`
    + __data.grid__: dataframe containignt all environmental variables and Coral growth parameters
    + __rep__: which replicate to run, i.e which row of master DF to use the parameters from
    + __Pred__: predation rate, proportion of larvae consumed
+ __Returns__:
    + __Results__: dataframe holding the ime series results for each pixels, saved as an .Rdata file

+ _Major Issues_: THis function performs well and quickly, issues only arise from the demography within.


```{r RunModel}
runModel = function(masterDF, PopData, COTS.data, Years = Years, data.grid, rep, Pred) {
  # browser()
  SexRatio = masterDF[rep, "SexRatio"]
  ConsRateW = masterDF[rep, "ConsRateW"]
  ConsRateS = masterDF[rep, "ConsRateS"]
  PCFParams = c(masterDF[rep, "avgPCF"], masterDF[rep,"sdPCF"])
  # avgPCF = masterDF[1, "avgPCF"]
  # sdPCF = masterDF[1, "sdPCF"]
  COTSmort = as.numeric(masterDF[rep, c("mortJ1", "mortJ2", "mortA")])
  COTSremain = as.numeric(masterDF[rep, c("remJ1", "remJ2", "remA")])
  COTS_StableStage = as.numeric(masterDF[rep, c("cssJ1", "cssJ2", "cssA")])
  # avgAdultSize =
  # sdAdultSize = # These will change the fecundity estimatesC
  # need an Allee Effect
  # need to make stable stage vary by a scaling factor
  # make mortality and remain resource driven
  
  
  # Initialize
  npops=npops
  seasons=seasons
  PopData = PopData[1:npops, ]
  COTS.data = COTS.data[1:npops, ]
  data.grid = data.grid[1:npops, ]
  
  # Work out which reefs from our connectivity matrix are to be included
  # which reefs from npops are being used in the analysis
  whichreefs = unique(data.grid$REEF_NAME[1:npops])
  ConnMat = COTS.ConnMat[1:length(whichreefs), 1:length(whichreefs)]
  Pixels = Pixels[1:length(colnames(ConnMat)),]
  FvDParams=FvDParams
  CoralCover=data.grid$pred.HCini.mean[1:npops]
  B0=data.grid$pred.b0.mean[1:npops]
  HC.asym=data.grid$pred.HCmax.mean[1:npops]
  WQ <- data.grid$Primary + data.grid$Secondary + data.grid$Tertiary
  #PCFParams = COTSPCF(npops, SexRatio = 5)
  # K = setCarryingCapacity(npops)
  # print(length(K$MinK.10A))
  COTSabund = initializeCOTSabund(PopData, COTS.data, 1996, stagenames, COTS_StableStage, npops)  # initialize the COTS abundance object (for year 0) 
  print(length(COTSabund[,3]))
  # Results = initializeModel(PopData, data.grid, COTSabund, CoralCover=CoralCover, SexRatio, 
  #                           ConsRateS, ConsRateW, B0, WQ, HC.asym, PCFParams, npops, ConnMat, FvDParams)
  Results = data.frame(sapply(PopData[1:4], rep, times=NYEARS*NSEASONS),
                       sapply(PopData[5:7], rep, times=NYEARS*NSEASONS),
                       Year=rep(1996:2015,each=2*npops), Season=rep(c("summer", "winter"),each=npops), 
                       COTSJ1=NA, COTSJ2=NA, COTSA=NA, CoralCover=NA, DistCOTS=NA, DistCYCL=NA, DistBLCH=NA)
  Results$CoralCover.Consum = NA
  Results$CoralCover.Growth = NA
  
  # browser()
  # year Loop
  for(year in Years){  
    print(year)# loop through years
    for(season in seasons){             # loop through seasons
      # browser()
      COTSabund = doCOTSDispersal(season,COTSabund,SexRatio,ConnMat, PCFParams, Pred, FvDParams)
      COTSabund = doCOTSDemography(season, COTSabund, COTSmort, COTSremain)
      COTSabund = doPredPreyDynamics(season, year, COTSabund, KC, CoralCover, Crash)
      Consumption = doCoralConsumption(year, data.grid, season, COTSabund, CoralCover, ConsRateS, ConsRateW)
      CoralCover = Consumption[,'CRemaining']
      CoralConsum = round(Consumption[,'CChange'],4)
      Growth = doCoralGrowth(CoralCover, B0, WQ, HC.asym)
      CoralCover = Growth[,'CoralCover']
      CoralGrowth = round(Growth[,'CoralGrowth'],4)
      #CoralCover = doCoralDisturbance(season,CoralCover,...)           # coral disturbance processes, including from COTS
      # browser()
      Results[(Results$Year==year) & (Results$Season==season),
              c("COTSJ1", "COTSJ2", "COTSA", "CoralCover", "CoralCover.Consum", 'CoralCover.Growth')] = 
        cbind(COTSabund, CoralCover,CoralConsum, CoralGrowth)
    }
  }
  setwd(RESULTS_DIRECTORY)
  name <- sprintf("Sample_%s.Rdata",rep)
  save(Results, file=name)
}
```

## HarvestData

## PlotResults

# Parameters 

This section outlines the different parameters that are currently tunable across LatinHypercube space.

+ __SexRatio__:
+ __ConsRateS__:
+ __ConsRateW__:
+ __avgPCF__:
+ __sdPCF__:
+ __mortJ1__:
+ __mortJ2__:
+ __mortA__:
+ __remJ1__:
+ __remJ2__:


# Data Structures

## data.grid

```{r data.grid}
library(knitr)
library(kableExtra)
kable(data.grid[1:100,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), font_size = 12) %>%
  scroll_box(width = "100%", height = "300px")
```

## data.COTS

```{r data.COTS, cache=TRUE}
kable(COTS.data[1:100,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), font_size = 12) %>%
  scroll_box(width = "100%", height = "300px")
```

## data.Bleach

## data.Cyclones

## COTS.ConnMat

```{r COTS.ConnMat, cache=T}
kable(COTS.ConnMat[1:50,1:50]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), font_size = 12) %>%
  column_spec(1, bold = T, border_right = T) %>%
  scroll_box(width = "100%", height = "300px")
```


## Results

```{r Results,cache=T, eval=F}
kable(Results[1:500,]) %>%
  kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"), font_size = 12) %>%
  scroll_box(width = "100%", height = "300px")
```

# Testing Arena
 
```{r, eval=F}
KC = (200*6.6*100)/0.5
for (i in 1:NREPS) {
runModel(masterDF=masterDF, Years = 1996:2015, PopData=PopData[1:npops,],COTS.data = COTS.data[1:npops,],
         data.grid = data.grid[1:npops,], rep=i, Pred=0.9)
}
test = HarvestData(RESULTS_DIRECTORY)
```

```{r Plot Results}
setwd(RESULTS_DIRECTORY)
load(sprintf("Sample_%s.Rdata",5))

library(ggplot2)
library(dplyr)
plotresults = Results %>% 
  filter(REEF_ID=="12-003a") %>%
  group_by(REEF_NAME,Year, Season) %>% 
  mutate(COTSA = (COTSA/100)*0.15) %>%
  summarise(COTSm = mean(COTSA, na.rm=T),
            COTSsd = sd(COTSA, na.rm = T),
            Coralm = mean(CoralCover, na.rm=T),
            Coralsd = sd(CoralCover, na.rm = T)) %>%
  mutate(Time = paste0(Year, substr(Season, 1,1)))
ggplot(data=plotresults, aes(x=Year, y=Coralm)) + geom_smooth() #+ geom_smooth(aes(y=COTSm))
ggplot(data=plotresults, aes(x=Year, y=COTSm)) + geom_smooth()
```
